---
---
---

# Dumpster

```{r dst}
install.packages("readxl")

```

```{r dst2}
library("readxl")
library(tidyverse)
library(dplyr)
install.packages("writexl")
library(writexl)
#read_excel("fatality rates h5n1.xlsx")
#getwd()

fat_data <- read_excel("fatality rates h5n1.xlsx")
fat_data
```

```{r apply}
fat_data <- fat_data|>
  mutate(w_sample = `Sample Size` / 145)



fat_data <- fat_data|>
  mutate(w_recency = 2.718^(-0.05 *`Years from 2024`))
print(fat_data)
write_xlsx(fat_data, "your_table.xlsx")
```

```{r}
fat_data <- fat_data|>
  mutate(final_weight = w_sample * w_recency)
print(fat_data)
write_xlsx(fat_data, "your_table.xlsx")


```

```{r}
fat_data$Fatality_Category <- with(fat_data, ifelse(`Fatality Rate` <= 0.10, "F1",
                                  ifelse(`Fatality Rate` <= 0.25, "F2",
                                  ifelse(`Fatality Rate` <= 0.50, "F3",
                                  ifelse(`Fatality Rate` <= 0.60, "F4", "F5")))))
fat_data
write_xlsx(fat_data, "your_table.xlsx")

```

```{r dumping_and_shafing}
install.packages('dst')

```

```{r real}
library(dst)
fat_data2 <- fat_data|>
  rowwise()|>
  mutate(array_col = case_when(
    Fatality_Category == "F1" ~ list(c(final_weight +(1 - final_weight)/5, (1 - final_weight)/5 ,      (1 - final_weight)/5 ,      (1 - final_weight)/5 ,      (1 - final_weight)/5 )),
    Fatality_Category == "F2" ~ list(c((1 - final_weight)/5 ,      final_weight+(1 - final_weight)/5, (1 - final_weight)/5 ,      (1 - final_weight)/5 ,      (1 - final_weight)/5 )),
    Fatality_Category == "F3" ~ list(c((1 - final_weight)/5 ,      (1 - final_weight)/5 ,      final_weight+(1 - final_weight)/5, (1 - final_weight)/5 ,      (1 - final_weight)/5 )),
    Fatality_Category == "F4" ~ list(c((1 - final_weight)/5 ,      (1 - final_weight)/5 ,      (1 - final_weight)/5 ,      final_weight+(1 - final_weight)/5, (1 - final_weight)/5 )),
    Fatality_Category == "F5" ~ list(c((1 - final_weight)/5 ,      (1 - final_weight)/5 ,      (1 - final_weight)/5 ,      (1 - final_weight)/5 ,      final_weight+(1 - final_weight)/5))
  ))|>
  ungroup()
fat_data2
write_xlsx(fat_data2, "arrays.xlsx")
str(fat_data2)
```

```{r stop_nesting}
weights <- fat_data2 
  #unnest_wider(array_col, names_sep = "_")
str(weights$array_col[[1]])

weights <- weights|>
   mutate(
    array_str = map_chr(array_col, ~ paste(round(.x, 3), collapse = ","))
  )
weights

str(weights)
#write_xlsx(weights, "weights.xlsx")

```

Reminder: we are working with a column that contains the lists that contains the numeric vectors that we want, fuck my life.

```{r uhhhhgh}
tt1 <- rbind(
  c(1, 0, 0, 0, 0, 0),  # F1
  c(0, 0, 0, 0, 0, 1),  # F6
  c(1, 1, 1, 1, 1, 1)   # Full frame
)# the frame of discerment or whatever
m1 <- weights$array_col
m1
library(purrr)

# A small helper to build a bca from a length-6 weight vector
bca_from_vector <- function(v, cnames = c("F1","F2","F3","F4","F5","F6"),
                            varname = "FatalityRate") {
  # Identify which positions in 'v' are non-zero
  non_zero_idx <- which(v != 0)

  # If all are zero (unlikely, but just in case), return a "vacuous" BCA?
  if (length(non_zero_idx) == 0) {
    stop("All-zero vector -- cannot create a BCA.")
  }

  # Build a 'tt' matrix: each row corresponds to a subset with 1 in the relevant column(s)
  # BUT in your scenario, each subset is just a single element: F1 or F2 or ...
  # So each focal element is a row of zeros except 1 in that focal element's column.
  # We'll do one row per non-zero element.
  tt_list <- lapply(non_zero_idx, function(i) {
    rowvec <- rep(0, 6)
    rowvec[i] <- 1
    rowvec
  })
  tt <- do.call(rbind, tt_list)  # combine rows

  # The masses are exactly the non-zero entries of v
  m <- v[non_zero_idx]

  # Create the bca object
  bca(
    tt     = tt, 
    m      = m,
    cnames = cnames,
    varnames = varname
  )
}

weights_bca <- weights %>%
  mutate(
    bca_obj = map(array_col, ~ bca_from_vector(.x))
  )

weights_bca
str(weights_bca)



```

```{r may}
combined_unnorm <- reduce(
  weights_bca$bca_obj,
  ~ dsrwon(.x, .y)     # .x is the "accumulator", .y is the next BCA
)
#combined_unnorm

# Now 'combined_unnorm' is a bcaspec representing the *unnormalized* combination.

combined_bca <- nzdsr(combined_unnorm)
#combined_bca

res_belplau <- belplau(combined_bca)
res_belplau
```

```{r}
1+1
```
